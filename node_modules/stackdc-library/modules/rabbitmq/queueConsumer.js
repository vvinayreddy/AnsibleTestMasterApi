var util = require('util');
var amqp = require('amqplib/callback_api');
var logger = require('log4js').getLogger('Rabbit-QueueConsumer');


function queueConsumer(config) {
    this.config = config;
    this.channel = undefined;
    this.conn = undefined;
    this.retryTimeOut = config.retryTimeOut ? config.retryTimeOut : 100;

}

queueConsumer.prototype.reConnect = function (cb, retryCount) {
    var _selfRef = this;

    var retryCount = retryCount ? retryCount + 1 : 1;

    logger.debug('Reconnecting Count:%s , Elapsed time: %s secs', retryCount, 30 * (retryCount - 1));

    // this.retryTimeOut < 0 means , retry forever
    if (this.retryTimeOut > 0 && retryCount > this.retryTimeOut) {
        //   cb(new Error('Maximum allowed retries completed.. '));
        logger.error('Maximum allowed retries completed.. Count:%s, Elaspsed time: %s Secs', retryCount - 1, 30 * (retryCount - 1))
    } else {
        setTimeout(function () {
                logger.debug('reConnect waiting done')
                _selfRef.onMessage(cb, retryCount);
            },
            30000 ); // retry every 10 secs
    }
}

queueConsumer.prototype.onError = function (cb) {
    logger.log('on Error');

}

queueConsumer.prototype.onMessage = function (cb, retryCount) {
    var _selfRef = this;
    try {
        amqp.connect(_selfRef.config.url, function (err, conn) {
            if (err) {
                logger.error("Error creating connection:" + _selfRef.config, err.message);
                _selfRef.reConnect(cb, retryCount)
            } else {
                _selfRef.conn = conn;
                logger.info("Initializing Consumer Connection", _selfRef.config);
                conn.createChannel(function (err, ch) {
                    if (err) {
                        logger.error("Error creating channel:" + _selfRef.config, err.message);
                    } else {
                        ch.assertQueue(_selfRef.config.queue, {
                            durable: _selfRef.config.durable ? _selfRef.config.durable : true
                        });
                        _selfRef.channel = ch;
                        logger.info("Channel Created:", _selfRef.config);
                        retryCount = 0; // reset after every successfull connection
                        _selfRef.channel.consume(_selfRef.config.queue, function (msg) {
                            // for backward compatibility with kafka consumer client.. should be removed after migration
                            msg.value = msg.content;

                            // if ack requied, send channel obj for ack
                            cb(msg, _selfRef.config.ack ? _selfRef.channel : undefined)
                        }, {
                            noAck: _selfRef.config.ack ? !_selfRef.config.ack : true
                        });
                    }
                });
                conn.on('error', function (err) {
                    logger.error('Consumer Connection Error:' + _selfRef.config.queue, err.message);
                    _selfRef.reConnect(cb, retryCount)
                });
            }
        });
    } catch (err) {
        logger.error('Error Initializing Consumer connection', err.message)
    }
}

module.exports = queueConsumer;