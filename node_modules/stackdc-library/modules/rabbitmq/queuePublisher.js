var amqp = require('amqplib/callback_api');
var logger = require('log4js').getLogger('Rabbit-QueuePublisher');
var ObjectID = require("bson-objectid");
const os = require('os');


var queuePublisher = function (config) {

    logger.info(' QueuePublisher constructor');

    this.config = config;
    this.isConnected = false;
    this.channel = undefined;
    this.conn = undefined;
    this.ack = config && config.ack ? config && config.ack : false;
    return this;
};



queuePublisher.prototype.init = function (config, cb) {
    this.config = config;
    if (cb)
        cb(undefined, true)
}

queuePublisher.prototype.connect = function (cb) {
    var _selfRef = this;

    try {
        if (this.isConnected) {
            cb(undefined, true);
        } else {
            amqp.connect(_selfRef.config.url, function (err, conn) {
                if (err) {
                    logger.error('Error connecting to queue:' + _selfRef.config.url, err.message);
                    _selfRef.isConnected = false;
                    cb(err)
                } else {
                    _selfRef.isConnected = true;
                    _selfRef.conn = conn;
                    conn.on('close', function (err) {
                        logger.error('Connection Closed:' + _selfRef.config.url, err.message);
                        _selfRef.isConnected = false;
                    });
                    conn.on('error', function (err) {
                        logger.error('Connection Error:' + _selfRef.config.url, err.message);
                        _selfRef.isConnected = false;
                    });

                    // create a channel
                    if (_selfRef.ack) {
                        _selfRef.conn.createConfirmChannel(function (err, ch) {
                            if (err) {
                                logger.error('Error Creating  Confirm Channel:' + _selfRef.config.url, err.message);
                                _selfRef.isConnected = false;
                                cb(err);
                            } else {
                                logger.debug("Confirm Channel Created for :", _selfRef.config.url);
                                _selfRef.channel = ch;
                                cb(undefined, true);
                            }
                        });
                    } else {
                        _selfRef.conn.createChannel(function (err, ch) {
                            if (err) {
                                logger.error('Error Creating Channel:' + _selfRef.config.url, err.message);
                                _selfRef.isConnected = false;
                                cb(err);
                            } else {
                                logger.debug("Channel Created for :", _selfRef.config.url);
                                _selfRef.channel = ch;
                                cb(undefined, true);
                            }
                        });

                    }
                }
            });
        }
    } catch (err) {
        logger.error('Exception in connect:', err.message);
        _selfRef.isConnected = false;
        cb(err);
    }

}

queuePublisher.prototype.publishMessage = function (queue, header, message, cb) {

    try {
        logger.debug('Publishing event to queue: ', queue);
        _selfRef = this;
        this.connect(function (err, status) {
            if (err) {
                logger.error('Error connecting to queue:', err.message);
                cb(err)
            } else {
                var messageEnv = {
                    queue: queue,
                    id: new ObjectID().toString(),
                    created: Date.now(),
                    host: os.hostname(),
                    header: header,
                    data: message
                };

                _selfRef.channel.assertQueue(queue, {
                    durable: _selfRef.config.durable ? _selfRef.config.durable : true
                });
                var msg = JSON.stringify(messageEnv);
                logger.debug('Sending Message:', msg);
                _selfRef.channel.sendToQueue(queue, new Buffer(msg), {}, function (err, ok) {
                    if (err !== null) {
                        logger.error('Message ACK error:', err.message);
                        cb(err);
                    } else
                        logger.trace('Message ACK ');
                        cb(undefined, true)
                });
                // for non confirm channel, send callback
                if (!_selfRef.ack) {
                    cb(undefined, true)
                }
            }

        });
    } catch (err) {
        logger.error('Exception publishing message:', err.message);
        cb(err);
    }


}

module.exports = queuePublisher;